## 方法的重写（override/overwrite）
### 1.重写：
子类继承父类以后，可以对父类中同名同参数的方法，进行覆盖操作。
### 2.应用：
重写以后，当创建子类对象以后，通过子类对象调用父类中的同名同参数的方法，实际执行的是父类重写父类的方法。
### 3.重写的规定：
>方法的声明：
>```java
>权限修饰符 返回值类型 方法名（形参列表）{
>                方法体
>}
>```
>约定俗称：子类中的叫重写的方法，父类中的叫被重写方法

①子类重写的方法的方法名和形参列表与父类被重写的方法的方法名和形参列表相同。
②子类重写的方法的权限修饰符不小于父类被重写的方法的权限修饰符。特殊情况：子类不能重写父类的private方法。
③返回值类型：
如果父类中被重写的方法的返回值类型是void，则子类重写的方法返回值只能是void。
父类被重写的方法的返回值类型是A类型，则子类重写的方法的返回值类型可以是A类或A类的子类。
父类被重写的方法的返回值类型是基本数据类型，则子类重写的方法的返回值类型必须是相同的基本数据类型。
④子类重写的方法抛出的异常类型不大于父类被重写方法抛出的异常类型。（具体放到异常处理再详细说明）
**********
 ***子类和父类中同名同参数的方法要么都非static的（考虑重写），要么都声明为static的（static是不能被重写的）***
 ### 区分：方法的重载和重写:
 #### 1.二者的定义细节
 略
 #### 2.从编译和运行的角度看：
 ##### 重载：
 是指允许存在多个同名方法，为这些方法的参数不同。编译器根据方法不同的参数表，对同名方法的名称做修饰。对于编译器而言，这些同名方法就成了不同的方法。***它们的调用地址在编译期就绑定了***。Java的重载是可以包括父类和子类的，即子类可以重载父类的同名不同参数的方法。
 所以：对于重载而言，在方法调用之前，编译器就已经确定了所要调用的方法，这称为“早绑定”或者“静态绑定”。
 ##### 重写：
 对于多态，只有等到方法调用的那一刻，编译器才会确定所调用的具体方法，而这称为“晚绑定”或者“动态绑定”。
 
##### 引用：
Bruce Eckel：“不要犯傻，如果它不是晚绑定，它就不是多态”
 ## 子类对象实例化的全过程
 ### 1.从结果是上来看
 >子类继承父类以后，就获取了父类中声明的属性或方法。
 >创建子类的对象，在堆空间中，就会加载所有父类中声明的属性。
### 2.从过程上来看
>当我们通过子类的构造器创建子类对象时，我们一定会直接或间接的调用其父类的构造器，进而调用父类的父类的构造器。直到调用了java.lang.Object类中空参的构造器为止。
>正因为加载过所有的父类的结构，所以才可以看到内存中有父类中的结构，子类对象才可以考虑进行调用。
### 虽然创建子类对象时，调用了父类的构造器，但是自始至终就创建了一个对象即为new的子类对象。
(⊙﹏⊙)b