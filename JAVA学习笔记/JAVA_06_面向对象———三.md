## 方法的重写（override/overwrite）
### 1.重写：
子类继承父类以后，可以对父类中同名同参数的方法，进行覆盖操作。
### 2.应用：
重写以后，当创建子类对象以后，通过子类对象调用父类中的同名同参数的方法，实际执行的是父类重写父类的方法。
### 3.重写的规定：
>方法的声明：
>```java
>权限修饰符 返回值类型 方法名（形参列表）{
>                方法体
>}
>```
>约定俗称：子类中的叫重写的方法，父类中的叫被重写方法

①子类重写的方法的方法名和形参列表与父类被重写的方法的方法名和形参列表相同。
②子类重写的方法的权限修饰符不小于父类被重写的方法的权限修饰符。特殊情况：子类不能重写父类的private方法。
③返回值类型：
如果父类中被重写的方法的返回值类型是void，则子类重写的方法返回值只能是void。
父类被重写的方法的返回值类型是A类型，则子类重写的方法的返回值类型可以是A类或A类的子类。
父类被重写的方法的返回值类型是基本数据类型，则子类重写的方法的返回值类型必须是相同的基本数据类型。
④子类重写的方法抛出的异常类型不大于父类被重写方法抛出的异常类型。（具体放到异常处理再详细说明）
**********
 ***子类和父类中同名同参数的方法要么都非static的（考虑重写），要么都声明为static的（static是不能被重写的）***
 ### 区分：方法的重载和重写:
 #### 1.二者的定义细节
 略
 #### 2.从编译和运行的角度看：
 ##### 重载：
 是指允许存在多个同名方法，为这些方法的参数不同。编译器根据方法不同的参数表，对同名方法的名称做修饰。对于编译器而言，这些同名方法就成了不同的方法。***它们的调用地址在编译期就绑定了***。Java的重载是可以包括父类和子类的，即子类可以重载父类的同名不同参数的方法。
 所以：对于重载而言，在方法调用之前，编译器就已经确定了所要调用的方法，这称为“早绑定”或者“静态绑定”。
 ##### 重写：
 对于多态，只有等到方法调用的那一刻，编译器才会确定所调用的具体方法，而这称为“晚绑定”或者“动态绑定”。
 
##### 引用：
Bruce Eckel：“不要犯傻，如果它不是晚绑定，它就不是多态”
 ## 子类对象实例化的全过程
 ### 1.从结果是上来看
 >子类继承父类以后，就获取了父类中声明的属性或方法。
 >创建子类的对象，在堆空间中，就会加载所有父类中声明的属性。
### 2.从过程上来看
>当我们通过子类的构造器创建子类对象时，我们一定会直接或间接的调用其父类的构造器，进而调用父类的父类的构造器。直到调用了java.lang.Object类中空参的构造器为止。
>正因为加载过所有的父类的结构，所以才可以看到内存中有父类中的结构，子类对象才可以考虑进行调用。
### 虽然创建子类对象时，调用了父类的构造器，但是自始至终就创建了一个对象即为new的子类对象。

### 重写equals()方法的原则
* 对称性：如果x.equals(y)返回是“true”，那么y.equals(x)也应该返回是“true”。
* 自反性：x.equals(x)必须返回是“true”。
* 传递性：如果x.equals(y)返回的是“true”,而且y.equals(z)返回是“true”,那么z.equals(x)也应该返回是“true”。
* 一致性：如果x.equals(y)返回是“true”,只要x和y的内容一直不变，不管重复x.equals(y)多少次，返回都是“true”。
* 任何情况下：x.equals(null),永远返回“false”；x.equals（和x不同类型的对象）永远返回是“false”。
(⊙﹏⊙)b
TCP/IP：应用层、运输层（进程通信服务、TCP）、网际层（负责把源主机的报文分组送到目的主机）、网络接口层（通过网络发送和接收IP数据报）
OSI:应用层、表示层（加密和解密、数据压缩与恢复、格式变换）、会话层、运输层、网络层、数据链路层、物理层
网络层协议：（IP、ICMP、ARP）（第二层）、RARP、TCP在第三层
IP数据报分片：源主机和路由器
IP：运输层、TCP：应用层
不参与封装工作是物理层
PDU：协议数据单元对等层之间
SDU：层与层

物理层：原始二进制传输（bit）
数据链路层：介质访问（frame帧）、保证数据正确的顺序、无错和完整。
网络层：负责路由和转发，确定地址和最佳路径（packet包）
运输层：端到端连接（segment段）
会话层：互联主机通信（插入同步点）
表示层：数据表示
应用层：为应用程序提供网络服务：第五至七层为节点传输，负责发送和接收消息
语义：规定需要发出何种控制信息以及完成的动作与做出的响应