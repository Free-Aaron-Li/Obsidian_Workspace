[[JAVA]]_05

[[数组]]，是多个*相同类型数据*按*一定顺序排列*的集合，并使用*一个名字命名*，并通过*编号*的方式对这些数据进行统一管理；

数组的常见概念：
>数组名
>下标（或索引）
>元素
>数组的长度

1.数组属于引用数据类型，数组的元素，既可以是基本数据类型，也可以是引用数据类型；
2.数组的长度一旦确定，就不可以修改；
3.数组分为：
>按照维数：一维、二维……
>按照数组元素类型：基本数据类型、引用数据类型；

静态初始化：数组的初始化和数组元素的赋值操作同时进行；  
>int[] ids;  
>ids = new int[]{1, 2, 3, 4, 5};  

动态初始化：数组的初始化和数组元素的赋值操作分开进行；  
>String[] names = new String[5];

获取[[数组长度]]
>属性：length;
>sout(names.length)；

遍历数组
>for(i=0;i<names.length;i++){
>sout(names[i]);
>}

默认初始化值
>数组元素是整型：0；
>数组元素是浮点型：0.0；
>数组元素是字符型：null;
>数组元素是char型：0或"\u0000"，不是“0”；
>数组元素是boolean型：false;

数组的内存解析
>JVM规范

内存结构：![[Pasted image 20211218211238.png]]
放在方法中的变量都是局部变量；
之哟啊是new出来的结构都放在堆里面；

## [[二维数组]]
1.理解
>对于二维数组的理解，我们可以看成是一维数组Array1又作为另一个一维数组Array2的元素而存在，其实，从数组底层的运行机制来看，其实没有多维数组；

2.二维数组的使用
>1.二维数组的声明和初始化；
>>静态数组：
>>>int [ ][ ]arr1=new int[ ][ ]{{1,2,3},{4,5,6}}; ①
>>
>>动态数组：
>>>1.String[ ][ ] arr2 = new String[3][2];
>>>2.String[ ][ ] arr3 = new String[3][ ];
>
>2.如何调用数组的指定位置的元素；
>>sout(arr1[0][1])//调用①中的2；
>>如果没有对二维数组声明，那么就会包空指针；Ps:sout(arr3[0][1]);
>
>3.如何获取数组的长度；
>>数组长度跟该二维数组里面有多少值没关系，只跟该数组长度有关;Ps：arr2.length=3;
>
>4.数组元素的默认初始化值；
>>数组元素是整型：0；
>>数组元素是浮点型：0.0；
>>数组元素是字符型：null;
>>数组元素是char型：0或"\u0000"，不是“0”；
>>数组元素是boolean型：false;
>>数组是应勇数据类型：null;
>>System.out.println(arr2[0]);//输出地址值：\[Ljava.lang.String;@119d7047 “\[”表示是一维数组，“String”表示是String类型，“@119d7047”表示地址值，“Ljava.lang”表示包名；
>>***
>>int[][] arr4 = new int[4][];  
>>System.out.println(arr4[1]);
>>这样写报null，表明你还没有初始化，表示空的；
>>如果这样写：
>>int[][] arr4 = new int[4][];  
>>System.out.println(arr4[1][0]);
>>会报空指针异常；
>
>5.数组的内存解析；
>>![[Pasted image 20211219150402.png]]
>

## 关于数组类型的写法
1.可以写成：
>int arr[ ]={1,2,3,4}; //*类型推断*，但是不可以写成：int arr;  arr[ ]={1,2,3,4};
>同理二维数组也可以写成int arr[ ][ ]={{1,2,3}{5,6,7}};
>当然上面是C写法，你可以写成int [ ] arr = {1,2,3,4,5};
>以上都是简写的写法，标准的写法还是要看上面数组的使用；

## [[数据结构]]
1.数据与数据之间的逻辑关系：集合、一对一、多对多；
2.数据的存储结构：
>线性表：（一对一）
>>顺序表（比如：数组）、链表、栈、队列；
>
>树型结构：（一对多）
>>二叉树；
>
>图形结构：（多对多）

## [[算法]]
排序算法：
搜索算法：

#[[数组中涉及的常见算法 ]]
>1.数组元素的赋值（杨辉三角、回形数）；
>2.求数值型数组中元素的最大值、最小值、平均值、总和等；
>3.数组的复制、反转、查找（线性查找、二分查找）；
>4.数组元素的排序算法；
>>[[衡量排序算法的优劣]]:
>>>1.时间复杂度:分析关键字的比较次数和记录的移动次数;
>>>2.空间复杂度:分析排序算法中需要多少辅助内存;
>>>3.稳定性:若两个记录A和B的关键字值相等,但排序后A,B的先后次序保持不变,则称这种排序算
>>>法是稳定的;

#[[十大内部排序算法]]
>选择排序：
>>直接选择排序、*堆排序*；
>交换排序：
>>**冒泡排序、快速排序**；
>插入排序：
>>直接插入排序、折半插入排序、Shell排序；
>*归并排序*
>桶式排序
>基数排序

#算法的5大特征
>输入(Inpot)：有0个或多个输入数据，这些收入必须有清楚的描述和定义；
>输出(Output)：至少有1个或多个输出结果，不可以没有输出结果；
>有穷性(有限性,Finiteness)：算法在有限的步骤之后会自动结束而不会无限循环，并且每一个步骤可以在可接受的时间内完成；
>确定性(明确性,Definiteness)：算法中的每一步都有确定的含义，不会出现二义性；
>可行性(有效性,Effectiveness)：算法的每一步都是清楚且可行的，能让用户用纸笔计算而求出答案；

*说明*：满足确定性的算法也称为：确定性算法；现在人们也关注更广泛的概念，例如考虑各种非确定性的算法,如并行算法、概率算法等。另外人们也关注并不要求终止的计算描述，这种描述有时被称为过程(procedure);

Arrays工具类使用
常见查找：
>boolean equals(int[] a,int[] b) ：判断两个数组是否相等；
>String toString(int[] a) ：输出数组信息；
>void sort(int[] a) ：对数组进行排序；
>void fill(int[] a,int val) ：将指定值填充到数组中；
>int binarySearch(int[] a,int key) ：对排序后的数组进行二分法查找；